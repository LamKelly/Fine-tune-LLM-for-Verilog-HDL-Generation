# -*- coding: utf-8 -*-
"""VerilogCodeGeneration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pr2cp6AtG3YqgwD-Cpko_syRLYqZfsoF
"""

!pip install unsloth unsloth_zoo bitsandbytes accelerate trl datasets huggingface_hub

!pip install transformers==4.36.2
!pip install --upgrade --force-reinstall --no-cache-dir unsloth unsloth_zoo

!pip install protobuf==3.20.3

!pip install gradio

!pip install gradio transformers accelerate

!pip install transformers gradio matplotlib
!sudo apt-get install iverilog

!apt-get update -qq
!apt-get install -y iverilog

!pip install transformers gradio matplotlib

!apt-get update -qq
!apt-get install -y iverilog
!pip install transformers gradio matplotlib

from huggingface_hub import login
login(token=" INSERT TOKEN")
import time
import gradio as gr
import subprocess
import re
import os
import matplotlib.pyplot as plt
from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline

# ---------- Model ----------
model_name = "KaranamSaiMounika/verilog-copilot-llama3"
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForCausalLM.from_pretrained(model_name)
pipe = pipeline("text-generation", model=model, tokenizer=tokenizer, return_full_text=False)

# ---------- Generate Verilog ----------
def generate_verilog_ui(prompt: str):

    instruction = (
        f"Write only the Verilog module definition for: {prompt}. "
        f"Do NOT include any explanation, comments, or extra text. "
        f"Output must start with 'module' and end with 'endmodule'."
    )
    result = pipe(
        instruction,
        max_new_tokens=500,
        temperature=0.7,
        do_sample=True
    )[0]["generated_text"]

    match = re.search(r"(module\s+\w+\s*\(.*?\);\s*.*?endmodule)", result, re.S)
    output = match.group(1).strip() if match else result.strip()
    output = re.sub(r"/\*.*?\*/", "", output, flags=re.S)
    output = re.sub(r"//.*", "", output)
    output = output.strip()

    # hide waveform image when new code is generated
    return output, gr.update(visible=False)

# ---------- Parse Verilog ----------
def parse_verilog(verilog_code: str):
    module_match = re.search(r"module\s+(\w+)\s*\((.*?)\)\s*;", verilog_code, re.S)
    if not module_match:
        return None, [], []
    module_name = module_match.group(1)
    inputs = re.findall(r"input\s+(?:wire\s+)?(\[[^\]]+\]\s+)?(\w+)", verilog_code)
    outputs = re.findall(r"output\s+(?:reg\s+|wire\s+)?(\[[^\]]+\]\s+)?(\w+)", verilog_code)
    return module_name, inputs, outputs

# ---------- Create Testbench ----------
def create_testbench(module_name, inputs, outputs):
    tb = "`timescale 1ns/1ps\nmodule tb;\n"
    for width, name in inputs:
        tb += f"    reg {width if width else ''}{name};\n"
    for width, name in outputs:
        tb += f"    wire {width if width else ''}{name};\n"
    tb += f"    {module_name} uut ({', '.join([f'.{p[1]}({p[1]})' for p in inputs + outputs])});\n\n"

    total_bits = 0
    for width, _ in inputs:
        if width:
            msb, lsb = map(int, width.strip('[]').split(':'))
            total_bits += abs(msb - lsb) + 1
        else:
            total_bits += 1

    tb += "    integer i;\ninitial begin\n"
    tb += '        $dumpfile("wave.vcd");\n'
    tb += '        $dumpvars(0, tb);\n'   # dump entire testbench
    for _, name in inputs:
        tb += f"        {name} = 0;\n"
    tb += "        #10;\n"
    tb += f"        for (i = 0; i < {2 ** total_bits}; i = i + 1) begin\n"
    if len(inputs) == 1:
        tb += f"            {inputs[0][1]} = i;\n"
    else:
        tb += f"            {{{', '.join([p[1] for p in inputs])}}} = i;\n"
    tb += "            #10;\n        end\n"
    tb += "        $finish;\n    end\nendmodule\n"
    return tb

# ---------- Plot Waveform ----------
def plot_waveform(vcd_file, verilog_code):
    signals, name_map = {}, {}
    current_time, last_time = 0, 0

    with open(vcd_file) as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            if line.startswith("$var"):
                parts = line.split()
                if len(parts) >= 5:
                    name_map[parts[3]] = parts[4]
                continue
            if line.startswith("#"):
                current_time = int(line[1:])
                last_time = current_time
                continue
            if line[0] in ["b", "B"]:
                value, symbol = line.split()
                name = name_map.get(symbol, symbol)
                try:
                    val_int = int(value[1:], 2)
                except ValueError:
                    val_int = 0
                signals.setdefault(name, []).append((current_time, val_int))
                continue
            if line[0] in ["0", "1"]:
                val = 1 if line[0] == "1" else 0
                symbol = line[1:]
                name = name_map.get(symbol, symbol)
                signals.setdefault(name, []).append((current_time, val))
                continue

    if not signals:
        print("no signals in VCD")
        return None

    # ports from Verilog
    _, inputs, outputs = parse_verilog(verilog_code)
    input_names = [n for _, n in inputs]
    output_names = [n for _, n in outputs]

    # group by base name (drop hierarchy)
    vcd_by_base = {}
    for full_name, changes in signals.items():
        base = full_name.split('.')[-1]
        vcd_by_base.setdefault(base, []).extend(changes)

    # keep only ports that appear in VCD
    filtered = {}
    for name in input_names + output_names:
        if name in vcd_by_base:
            changes = sorted(vcd_by_base[name])
            if changes[-1][0] < last_time:
                changes.append((last_time, changes[-1][1]))
            filtered[name] = changes

    if not filtered:
        print("no ports found in VCD")
        return None

    ordered_names = [n for n in input_names if n in filtered] + \
                    [n for n in output_names if n in filtered]

    plt.figure(figsize=(10, len(ordered_names) * 1.5))
    handles = []
    for i, name in enumerate(ordered_names):
        times, values = zip(*filtered[name])
        line, = plt.step(times, [v + i * 2 for v in values],
                         where="post", label=name)
        handles.append(line)

    plt.yticks([i * 2 for i in range(len(ordered_names))], ordered_names)
    plt.xlabel("Time (ns)")
    plt.title("Waveform")
    plt.grid(True)
    plt.gca().invert_yaxis()

    leg = plt.legend(handles, ordered_names,
                     loc="center left", bbox_to_anchor=(1.02, 0.5),
                     borderaxespad=0.0)

    img_path = "waveform.png"
    plt.savefig(img_path, bbox_extra_artists=(leg,), bbox_inches="tight")
    plt.close()
    return img_path

# ---------- Show Waveform ----------
def show_waveform_ui(verilog_code):
    module_name, inputs, outputs = parse_verilog(verilog_code)
    if not module_name:
        return gr.update(visible=False)
    with open("module.v", "w") as f:
        f.write(verilog_code)
    tb_code = create_testbench(module_name, inputs, outputs)
    with open("tb.v", "w") as f:
        f.write(tb_code)
    try:
        subprocess.run(["iverilog", "-o", "sim.out", "module.v", "tb.v"], check=True)
        subprocess.run(["vvp", "sim.out"], check=True)
    except subprocess.CalledProcessError:
        return gr.update(visible=False)
    if not os.path.exists("wave.vcd"):
        return gr.update(visible=False)
    img = plot_waveform("wave.vcd", verilog_code)
    return gr.update(value=img, visible=True) if img else gr.update(visible=False)

# ---------- Gradio UI ----------
with gr.Blocks(theme=gr.themes.Soft()) as demo:
    gr.Markdown("<h1 style='text-align:center;color:#4CAF50;'>⚡ Verilog Code Generation - Powered by LLaMA3 ⚡</h1>")
    with gr.Row():
        with gr.Column(scale=1):
            prompt_input = gr.Textbox(label="Enter your prompt", placeholder="e.g., 2 bit full adder", lines=4)
            generate_btn = gr.Button("Generate Verilog Code", variant="primary")
            waveform_btn = gr.Button("Show Waveform", variant="secondary")
        with gr.Column(scale=1):
            verilog_output = gr.Textbox(label="Generated Verilog Code", lines=15, show_copy_button=True)
            waveform_output = gr.Image(label="Waveform Visualization", type="filepath", visible=False)

    generate_btn.click(generate_verilog_ui, inputs=prompt_input,
                       outputs=[verilog_output, waveform_output])
    waveform_btn.click(show_waveform_ui, inputs=verilog_output,
                       outputs=[waveform_output])

demo.launch(share=True)